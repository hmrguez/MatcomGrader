using Common;
using NUnit.Framework.Interfaces;

namespace AutoGrader;

[TestFixture]
public abstract class GenericTest<TProblem, TOutput>
    where TProblem : ITestProblem<TOutput>, new()
{
    [TearDown]
    public void TearDown()
    {
        // Retrieve the category of the current test
        var category =
            TestContext.CurrentContext.Test.Properties["Category"] is List<object> { Count: > 0 } categoryList
                ? categoryList[0] as string ?? "Uncategorized"
                : "Uncategorized";

        // Initialize counts for this category if not already present
        if (!_countsByCategory.ContainsKey(category))
        {
            _countsByCategory[category] = new TestOutcomeCounts();
        }

        var counts = _countsByCategory[category];

        // Determine the outcome of the test
        var outcome = TestContext.CurrentContext.Result.Outcome.Status;
        var message = TestContext.CurrentContext.Result.Message;

        switch (outcome)
        {
            case TestStatus.Passed:
                counts.PassedCount++;
                break;
            case TestStatus.Failed:
                if (message != null && message.Contains("TIMEOUT"))
                    counts.TimeoutCount++;
                else if (message != null && message.Contains("WRONG"))
                    counts.WrongCount++;
                else
                    counts.ExceptionCount++;
                break;
        }
    }

    [OneTimeTearDown]
    public void OneTimeTearDown()
    {
        var score = Grader.Grade(_countsByCategory);

        if (Global)
        {
            // Aggregate results across all categories
            int totalPassed = 0;
            int totalWrong = 0;
            int totalException = 0;
            int totalTimeout = 0;

            foreach (var counts in _countsByCategory.Values)
            {
                totalPassed += counts.PassedCount;
                totalWrong += counts.WrongCount;
                totalException += counts.ExceptionCount;
                totalTimeout += counts.TimeoutCount;
            }

            // Write flat results
            var mdHeaders = new[] { "Name", "Score", "✅ Passed", "⭕️ Wrong", "‼️ Exceptions", "⏰ Timeouts" };
            var writer = new MarkdownWriter(MdPath, mdHeaders);
            
            writer.AddRow(Name, score, totalPassed.ToString(), totalWrong.ToString(), totalException.ToString(),
                totalTimeout.ToString());
        }
        else
        {
            // Write grouped results by category
            // Prepare headers
            var headers = new List<string> { "Name", "Score" };
            var categoryList = _countsByCategory.Keys.ToList();
            categoryList.Sort(); 

            headers.AddRange(categoryList);
            var writer = new MarkdownWriter(MdPath, headers.ToArray());

            // Prepare data row
            var dataRow = new List<string> { Name, score };
            dataRow.AddRange(categoryList
                .Select(category => _countsByCategory[category])
                .Select(counts =>
                    $"✅ {counts.PassedCount} / ⭕️ {counts.WrongCount} / ‼️ {counts.ExceptionCount} / ⏰ {counts.TimeoutCount}"));

            writer.AddRow(dataRow.ToArray());
        }

        Console.WriteLine("Test summary written to results.md");
    }

    // Configuration Constants
    private static readonly int NumberOfCases = int.Parse(Environment.GetEnvironmentVariable("NUMBER_OF_CASES") ?? "2");
    private const int RandomSeed = 10;
    private const string MdPath = "../../../../results.md";
    private static readonly string Name = Environment.GetEnvironmentVariable("CURRENT_SOLUTION_FILE") ?? "..";
    private static readonly bool Global = Environment.GetEnvironmentVariable("GLOBAL")! == "TRUE";

    private readonly Dictionary<string, TestOutcomeCounts> _countsByCategory = new();

    protected static readonly TProblem Problem = new();


    [Test]
    [TestCaseSource(nameof(GetTestCases))]
    public void AutoGeneratedSolutions(object[] parameters, TOutput expectedOutput)
    {
        var task = Task.Run(() => Problem.StudentSolution(parameters));

        if (task.Wait(TimeSpan.FromSeconds(5)))
        {
            var actualOutput = task.Result;
            var isEqual = Problem.CompareSolutions(expectedOutput, actualOutput);

            Assert.IsTrue(isEqual, $"WRONG Expected: {expectedOutput}, Actual: {actualOutput}");
        }
        else
        {
            Assert.Fail("TIMEOUT");
        }
    }

    private static IEnumerable<TestCaseData> GetTestCases()
    {
        foreach (var testCase in Problem.GenerateTestCases(RandomSeed, NumberOfCases))
            yield return new TestCaseData(testCase[0], testCase[1])
                .SetName($"Input_{testCase[0]}_Expected_{testCase[1]}");
    }
}