using Common;
using Exam;
using Grader;
using NUnit.Framework.Interfaces;

namespace AutoGrader;

[TestFixture]
public abstract class GenericTest<TProblem, TInput, TOutput>
    where TProblem : ITestProblem<TInput, TOutput>, new()
{
    // Configuration Constants
    private const int NumberOfCases = 10;
    private const int RandomSeed = 10;
    private const string MdPath = "../../../../results.md";
    private static readonly string[] MdHeaders = ["Name", "Passed", "Exceptions", "Timeouts"];
    private static readonly string Name = Environment.GetEnvironmentVariable("CURRENT_SOLUTION_FILE")!;

    private static readonly TProblem Problem = new TProblem();


    // Counters to track test outcomes
    private int _passedCount;
    private int _exceptionCount;
    private int _timeoutCount;


    [Test, TestCaseSource(nameof(GetTestCases))]
    public void AutoGeneratedSolutions(TInput input, TOutput expectedOutput)
    {
        var task = Task.Run(() => Problem.StudentSolution(input));

        if (task.Wait(TimeSpan.FromSeconds(5)))
        {
            var actualOutput = task.Result;
            var isEqual = Problem.CompareSolutions(expectedOutput, actualOutput);
            Assert.IsTrue(isEqual, $"Expected: {expectedOutput}, Actual: {actualOutput}");
        }
        else
        {
            Assert.Fail("Timeout");
        }
    }


    [TearDown]
    public void TearDown()
    {
        // Determine the outcome of the test
        var outcome = TestContext.CurrentContext.Result.Outcome.Status;
        var message = TestContext.CurrentContext.Result.Message;

        Console.WriteLine("Outcome: " + outcome);
        Console.WriteLine("Message: " + message);

        switch (outcome)
        {
            case TestStatus.Passed:
                _passedCount++;
                break;
            case TestStatus.Failed:
                if (message!.Contains("Timeout"))
                {
                    _timeoutCount++;
                }
                else
                {
                    _exceptionCount++;
                }

                break;
        }
    }


    [OneTimeTearDown]
    public void OneTimeTearDown()
    {
        var totalTests = NumberOfCases;
        var totalCounted = _passedCount + _exceptionCount + _timeoutCount;

        // If there's a discrepancy, add the difference to _exceptionCount
        if (totalCounted < totalTests)
        {
            var difference = totalTests - totalCounted;
            _exceptionCount += difference;
        }

        var writer = new MarkdownWriter(MdPath, MdHeaders);
        writer.AddRow(Name, _passedCount.ToString(), _exceptionCount.ToString(), _timeoutCount.ToString());

        Console.WriteLine("Test summary written to results.md");
    }


    private static IEnumerable<TestCaseData> GetTestCases()
    {
        foreach (var testCase in Problem.GenerateTestCases(RandomSeed, NumberOfCases))
        {
            yield return new TestCaseData(testCase[0], testCase[1])
                .SetName($"Input_{testCase[0]}_Expected_{testCase[1]}");
        }
    }
}