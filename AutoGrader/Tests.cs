using Common;
using Newtonsoft.Json;
using NUnit.Framework.Interfaces;

namespace AutoGrader;

[TestFixture]
public abstract class GenericTest<TProblem, TOutput>
    where TProblem : ITestProblem<TOutput>, new()
{
    [TearDown]
    public void TearDown()
    {
        // Retrieve the category of the current test
        var category =
            TestContext.CurrentContext.Test.Properties["Category"] is List<object> { Count: > 0 } categoryList
                ? categoryList[0] as string ?? "Uncategorized"
                : "Uncategorized";

        // Initialize counts for this category if not already present
        if (!_countsByCategory.ContainsKey(category))
        {
            _countsByCategory[category] = new TestOutcomeCounts();
        }

        var counts = _countsByCategory[category];

        // Determine the outcome of the test
        var outcome = TestContext.CurrentContext.Result.Outcome.Status;
        var message = TestContext.CurrentContext.Result.Message;

        switch (outcome)
        {
            case TestStatus.Passed:
                counts.PassedCount++;
                break;
            case TestStatus.Failed:
                if (message != null && message.Contains("TIMEOUT"))
                    counts.TimeoutCount++;
                else if (message != null && message.Contains("WRONG"))
                    counts.WrongCount++;
                else
                    counts.ExceptionCount++;
                
                _failedTestCases.Add(TestContext.CurrentContext.Test.Name.Replace("TestCase_", ""));
                
                break;
        }
    }

    [OneTimeTearDown]
    public void OneTimeTearDown()
    {
        var score = Grader.Grade(_countsByCategory);

        if (_global)
        {
            // Aggregate results across all categories
            int totalPassed = 0;
            int totalWrong = 0;
            int totalException = 0;
            int totalTimeout = 0;

            foreach (var counts in _countsByCategory.Values)
            {
                totalPassed += counts.PassedCount;
                totalWrong += counts.WrongCount;
                totalException += counts.ExceptionCount;
                totalTimeout += counts.TimeoutCount;
            }

            // Write flat results
            var mdHeaders = Constants.GlobalHeaders;
            var writer = new MarkdownWriter(_mdPath, mdHeaders);

            writer.AddRow(_name, score, totalPassed.ToString(), totalWrong.ToString(), totalException.ToString(),
                totalTimeout.ToString(), string.Join(", ", _failedTestCases));
        }
        else
        {
            // Write grouped results by category
            // Prepare headers
            var headers = new List<string> { "Name", "Score" };
            var categoryList = _countsByCategory.Keys.ToList();
            categoryList.Sort();

            headers.AddRange(categoryList);
            headers.Add(Constants.GlobalHeaders[^1]);
            var writer = new MarkdownWriter(_mdPath, headers.ToArray());

            // Prepare data row
            var dataRow = new List<string> { _name, score };
            dataRow.AddRange(categoryList
                .Select(category => _countsByCategory[category])
                .Select(counts =>
                    $"‚úÖ {counts.PassedCount} / ‚≠ïÔ∏è {counts.WrongCount} / üí• {counts.ExceptionCount} / ‚è∞ {counts.TimeoutCount}"));

            dataRow.Add(string.Join(", ", _failedTestCases));
            
            writer.AddRow(dataRow.ToArray());
        }

        Console.WriteLine("Test summary written to results.md");
    }

    // Configuration Constants
    private static readonly int RandomSeed = 10;
    private static readonly int NumberOfCases = int.Parse(Environment.GetEnvironmentVariable("NUMBER_OF_CASES") ?? "2");
    private static readonly string[] SpecificTestCases = Environment.GetEnvironmentVariable("SPECIFIC_TEST_CASES")?.Split(",", StringSplitOptions.RemoveEmptyEntries) ?? []; 
    private readonly string _mdPath = "../../../../" + Constants.ResultFileName;
    private static readonly string _cachedResultPath = "../../../../output/cached-results.md";
    private readonly string _name = Environment.GetEnvironmentVariable("CURRENT_SOLUTION_FILE") ?? "..";
    private readonly bool _global = Environment.GetEnvironmentVariable("GLOBAL")! == "TRUE";

    private readonly Dictionary<string, TestOutcomeCounts> _countsByCategory = new();
    private List<string> _failedTestCases = [];

    protected static readonly TProblem Problem = new();


    [Test]
    [TestCaseSource(nameof(GetTestCases))]
    public void AutoGeneratedSolutions(object[] parameters, TOutput expectedOutput)
    {
        var task = Task.Run(() => Problem.StudentSolution(parameters));

        if (task.Wait(TimeSpan.FromSeconds(5)))
        {
            var actualOutput = task.Result;
            var isEqual = Problem.CompareSolutions(expectedOutput, actualOutput);

            Assert.IsTrue(isEqual, $"WRONG Expected: {expectedOutput}, Actual: {actualOutput}");
        }
        else
        {
            Assert.Fail("TIMEOUT");
        }
    }
    
    public static IEnumerable<TestCaseData> GetTestCases()
    {
        List<TestCase> testCases;

        if (File.Exists(_cachedResultPath))
        {
            // Cache file exists; load test cases from it
            testCases = LoadTestCasesFromJson();
            Console.WriteLine("Loaded test cases from cache.");
        }
        else
        {
            // Cache file does not exist; generate new test cases
            testCases = GenerateAndCacheTestCases();
            Console.WriteLine("Generated and cached new test cases.");
        }

        // Convert TestCase objects to TestCaseData
        foreach (var testCase in testCases)
        {
            yield return (new TestCaseData(testCase.Parameters, testCase.ExpectedResult)
                .SetName($"TestCase_{testCase.Index}"));
        }
    }
    
    public record TestCase(object[] Parameters, TOutput ExpectedResult, object Index);


    private static List<TestCase> GenerateAndCacheTestCases()
    {
        List<TestCase> testCases = new List<TestCase>(NumberOfCases);
        int index = 0;

        foreach (var testCase in Problem.GenerateTestCases(RandomSeed, NumberOfCases))
        {
            testCases.Add(new TestCase((object[])testCase[0], (TOutput)testCase[1], index++));
        }

        SaveTestCasesToJson(testCases);
        return testCases;
    }

    private static void SaveTestCasesToJson(IEnumerable<TestCase> testCases)
    {
        var directory = Path.GetDirectoryName(_cachedResultPath);

        // Ensure the directory exists
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }


        // Serialize the test cases to JSON
        var json = JsonConvert.SerializeObject(testCases, Formatting.Indented);
        File.WriteAllText(_cachedResultPath, json);
    }

    private static List<TestCase> LoadTestCasesFromJson()
    {
        var json = File.ReadAllText(_cachedResultPath);
        var deserialized = JsonConvert.DeserializeObject<List<TestCase>>(json) 
               ?? new List<TestCase>();

        if (SpecificTestCases.Length == 0)
            return deserialized;


        var result = new List<TestCase>();
        foreach (var specificTestCase in SpecificTestCases.Select(x=>int.Parse(x)))
        {
            result.Add(deserialized[specificTestCase]);
        }

        return result;
    }
}